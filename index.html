<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Streaming Letters Demo</title>
</head>

<body>
  <button id="startButton" type="button">Start</button>
  <label style="margin-left: 12px; color: #000000; font-family: monospace;">
    <input id="randomToggle" type="checkbox" checked />
    Randomize Spawn Offsets
  </label>
  <label style="margin-left: 12px; color: #000000; font-family: monospace;">
    <input id="fragmentBoundsToggle" type="checkbox" />
    Show Fragment Bounds
  </label>
  <label style="margin-left: 12px; color: #000000; font-family: monospace;">
    <input id="slotBoundsToggle" type="checkbox" />
    Show Slot Targets
  </label>
  <label style="margin-left: 12px; color: #000000; font-family: monospace;">
    <input id="slotVectorToggle" type="checkbox" />
    Show Slot Vectors
  </label>
  <label style="margin-left: 12px; color: #000000; font-family: monospace;">
    <input id="colorCodingToggle" type="checkbox" checked />
    Show Cluster Colors
  </label>
  <canvas id="streamCanvas"></canvas>
  <script type="module">
    (() => {
      const button = document.getElementById('startButton');
      const randomToggle = document.getElementById('randomToggle');
      const fragmentBoundsToggle = document.getElementById('fragmentBoundsToggle');
      const slotBoundsToggle = document.getElementById('slotBoundsToggle');
      const slotVectorToggle = document.getElementById('slotVectorToggle');
      const colorCodingToggle = document.getElementById('colorCodingToggle');
      const canvas = document.getElementById('streamCanvas');
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        console.error('Unable to acquire 2D context.');
        if (button) {
          button.disabled = true;
        }
        if (colorCodingToggle) {
          colorCodingToggle.checked = config.colorCodingEnabled;
        }
        return;
      }

      const logTimestamp = () => new Date().toISOString();
      const log = (...args) => console.log(`[${logTimestamp()}]`, ...args);
      const warn = (...args) => console.warn(`[${logTimestamp()}]`, ...args);
      const error = (...args) => console.error(`[${logTimestamp()}]`, ...args);

      const config = {
        fontSize: 24,
        fontFamily: 'monospace',
        background: '#030712',
        foreground: '#f8fafc',
        clusterColors: [
          '#facc15',
          '#38bdf8',
          '#f472b6',
          '#34d399',
          '#a78bfa',
          '#fb7185',
        ],
        railPadding: 24,
        railFraction: 0.12,
        lineHeightMultiplier: 1.4,
        clusterRiseSpeedFinal: 260,
        clusterRiseSpeedPending: 110,
        fragmentMaxOffsetX: 110,
        fragmentMaxOffsetY: 60,
        fragmentMaxRotation: 0.7,
        fragmentReturnSpeed: 6,
        fragmentMoveSpeedMin: 0.85,
        fragmentMoveSpeedMax: 1.25,
        fragmentRandomizationEnabled: true,
        showFragmentBounds: false,
        showSlotBounds: false,
        showSlotVectors: false,
        colorCodingEnabled: true,
      };

      const state = {
        clusters: [],
        clusterMap: new Map(),
        activeCluster: null,
        recognition: null,
        isListening: false,
        keepListening: false,
        lastFrameTime: performance.now(),
        pendingLineY: null,
        pendingLineTargetY: null,
        metrics: {
          width: window.innerWidth || 0,
          height: window.innerHeight || 0,
          glyphWidth: 12,
          railY: 40,
          dpr: window.devicePixelRatio || 1,
        },
        colorCursor: 0,
        stream: {
          entries: [],
          fragments: new Map(),
          fading: new Set(),
          nextId: 0,
          lastDiff: null,
        },
      };

      // ------------------------------------------------------------------
      // Utility helpers
      // ------------------------------------------------------------------

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      const withGlyphWidth = () =>
        state.metrics.glyphWidth && state.metrics.glyphWidth > 0
          ? state.metrics.glyphWidth
          : 12;

      const randomBetween = (min, max) => Math.random() * (max - min) + min;

      const isRenderableChar = (ch) =>
        typeof ch === 'string' && ch.trim().length > 0;

        const leadingRenderableOffset = (entries) => {
          let offset = 0;
          while (offset < entries.length && !isRenderableChar(entries[offset]?.char)) {
            offset += 1;
          }
          return offset;
        };

        const round2 = (value) => Math.round(value * 100) / 100;

      const nextClusterColor = () => {
        const palette = config.clusterColors;
        if (!Array.isArray(palette) || palette.length === 0) {
          return config.foreground;
        }
        const color = palette[state.colorCursor % palette.length];
        state.colorCursor += 1;
        return color;
      };

      const updateButtonUI = ({ disabled, label } = {}) => {
        if (!button) {
          return;
        }
        if (typeof label === 'string') {
          button.textContent = label;
        } else {
          button.textContent = state.isListening ? 'Stop' : 'Start';
        }
        if (typeof disabled === 'boolean') {
          button.disabled = disabled;
        }
      };

      const updateToggles = () => {
        if (randomToggle) {
          randomToggle.checked = config.fragmentRandomizationEnabled;
        }
        if (fragmentBoundsToggle) {
          fragmentBoundsToggle.checked = config.showFragmentBounds;
        }
        if (slotBoundsToggle) {
          slotBoundsToggle.checked = config.showSlotBounds;
        }
        if (slotVectorToggle) {
          slotVectorToggle.checked = config.showSlotVectors;
        }
      };

      updateButtonUI();
      updateToggles();

      /**
       * Assign each cluster a top-aligned target row; unfinished clusters share the
       * pending band visually but maintain their own distance to the final slot.
       */
      const layoutClusters = () => {
        const lineHeight = config.fontSize * (config.lineHeightMultiplier || 1.4);
        const topPadding = config.fontSize * 1.25;
        const spawnY = Math.max(state.metrics.height - config.fontSize * 1.5, topPadding);
        const previousPendingY =
          typeof state.pendingLineY === 'number' ? state.pendingLineY : null;

        state.clusters.forEach((cluster, index) => {
          if (typeof cluster.x !== 'number') {
            cluster.x = config.railPadding;
          }

          const finalTargetY = topPadding + index * lineHeight;
          cluster.finalTargetY = finalTargetY;
          cluster.railY = finalTargetY;

          if (!cluster.hasSpawned) {
            const spawnSource =
              !cluster.isFinal && previousPendingY !== null
                ? previousPendingY
                : spawnY;
            cluster.spawnY = spawnSource;
            cluster.y = spawnSource;
            cluster.hasSpawned = true;
          } else if (typeof cluster.spawnY !== 'number') {
            const spawnSource =
              !cluster.isFinal && previousPendingY !== null
                ? previousPendingY
                : typeof cluster.y === 'number'
                  ? cluster.y
                  : spawnY;
            cluster.spawnY = spawnSource;
            if (typeof cluster.y !== 'number') {
              cluster.y = spawnSource;
            }
          }

          const originY =
            typeof cluster.spawnY === 'number' ? cluster.spawnY : spawnY;
          cluster.finalInitialDistance = Math.max(
            Math.abs(originY - finalTargetY),
            1
          );
        });

        const firstUnfinished = state.clusters.findIndex((cluster) => !cluster.isFinal);
        const firstPendingCluster =
          firstUnfinished >= 0 ? state.clusters[firstUnfinished] : null;
        if (firstUnfinished === -1) {
          state.pendingLineTargetY = null;
          state.pendingLineY = null;
        } else {
          state.pendingLineTargetY = topPadding + firstUnfinished * lineHeight;
          if (typeof state.pendingLineY !== 'number') {
            state.pendingLineY =
              (firstPendingCluster &&
                typeof firstPendingCluster.spawnY === 'number'
                ? firstPendingCluster.spawnY
                : spawnY);
          }
        }

        const glyphWidth = withGlyphWidth();
        const clusterGap = 0; // keep interim clusters contiguous
        let pendingCursorX = config.railPadding;
        let lastRowY = null;

        state.clusters.forEach((cluster) => {
          const spanLength = Math.max(
            (cluster.endIndex ?? 0) - (cluster.startIndex ?? 0),
            0
          );
          const spanEntries = state.stream.entries.slice(
            cluster.startIndex ?? 0,
            cluster.endIndex ?? 0
          );
          const leadingInvisible = leadingRenderableOffset(spanEntries);

          let targetY;
          if (cluster.isFinal) {
            targetY = cluster.finalTargetY;
            cluster.finalBaseX = config.railPadding;
            cluster.x = cluster.finalBaseX;
            cluster.pendingTargetY = null;
            cluster.pendingInitialDistance = null;
          } else {
            targetY = state.pendingLineTargetY ?? cluster.finalTargetY;
            cluster.pendingBaseX = pendingCursorX;
            cluster.x = cluster.pendingBaseX;
          }

          const sameRow =
            typeof targetY === 'number' &&
            typeof lastRowY === 'number' &&
            Math.abs(targetY - lastRowY) < 0.5;
          cluster.renderOffset = sameRow ? 0 : leadingInvisible;
          if (!sameRow && typeof targetY === 'number') {
            lastRowY = targetY;
          }

          const visibleLength = Math.max(spanLength - cluster.renderOffset, 0);
          cluster.visibleLength = Math.max(visibleLength, 0);
          const widthUnits = cluster.visibleLength > 0 ? cluster.visibleLength : 1;
          const clusterWidth = widthUnits * glyphWidth;

          if (cluster.isFinal) {
            cluster.targetY = targetY;
            const originY =
              typeof cluster.spawnY === 'number'
                ? cluster.spawnY
                : typeof cluster.y === 'number'
                ? cluster.y
                : spawnY;
            cluster.finalInitialDistance = Math.max(
              Math.abs(originY - (targetY ?? originY)),
              1
            );
          } else {
            cluster.targetY = targetY;
            pendingCursorX = cluster.pendingBaseX + clusterWidth + clusterGap;
            if (cluster.pendingTargetY !== targetY) {
              cluster.pendingTargetY = targetY;
              const originY =
                typeof cluster.spawnY === 'number'
                  ? cluster.spawnY
                  : typeof cluster.y === 'number'
                  ? cluster.y
                  : spawnY;
              cluster.pendingInitialDistance = Math.max(
                Math.abs(originY - (targetY ?? originY)),
                1
              );
            } else if (cluster.pendingInitialDistance == null) {
              const originY =
                typeof cluster.spawnY === 'number'
                  ? cluster.spawnY
                  : typeof cluster.y === 'number'
                  ? cluster.y
                  : spawnY;
              cluster.pendingInitialDistance = Math.max(
                Math.abs(originY - (targetY ?? originY)),
                1
              );
            }
          }

          assignFinalSlots(cluster);
        });
      };

      /** Resize the canvas for the current DPR and refresh layout metrics. */
      const setCanvasSize = () => {
        const dpr = window.devicePixelRatio || 1;
        const width = window.innerWidth;
        const height = window.innerHeight;

        canvas.width = Math.round(width * dpr);
        canvas.height = Math.round(height * dpr);
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.font = `${config.fontSize}px ${config.fontFamily}`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';

        const glyphWidth = ctx.measureText('M').width || 12;
        const railY = Math.max(config.fontSize * 2, height * config.railFraction);

        state.metrics = {
          width,
          height,
          glyphWidth,
          railY,
          dpr,
        };

        layoutClusters();
      };

      setCanvasSize();
      window.addEventListener('resize', setCanvasSize);

      // ------------------------------------------------------------------
      // Rendering
      // ------------------------------------------------------------------

      /** Paint the dark background before rendering clusters. */
      const drawBackground = () => {
        ctx.globalAlpha = 1;
        ctx.fillStyle = config.background;
        ctx.fillRect(0, 0, state.metrics.width, state.metrics.height);
        ctx.fillStyle = config.foreground;
      };

      const drawLetter = (ch, x, y, opacity, color) => {
        if (!ch || opacity <= 0) {
          return;
        }
        ctx.globalAlpha = clamp(opacity, 0, 1);
        if (color) {
          ctx.fillStyle = color;
        }
        ctx.fillText(ch, x, y);
      };

      /** Render a cluster's fragments and optional debugging bounds. */
      const drawCluster = (cluster) => {
        const glyphWidth = withGlyphWidth();
        const entries = state.stream.entries;
        const span = entries.slice(cluster.startIndex ?? 0, cluster.endIndex ?? 0);
        if (!span.length) {
          if (config.showSlotBounds && Array.isArray(cluster.finalSlots)) {
            cluster.finalSlots.forEach((slot) => {
              if (!slot) {
                return;
              }
              ctx.save();
              ctx.lineWidth = 1;
              ctx.strokeStyle = 'rgba(255, 0, 0, 0.35)';
              ctx.strokeRect(slot.x, slot.y, slot.width, slot.height);
              ctx.restore();
            });
          }
          return;
        }
          const color = config.colorCodingEnabled ? cluster.color || config.foreground : config.foreground;
          const currentY = cluster.y ?? cluster.railY;
          const occupiedSlots = new Set();

          const renderOffset = cluster.renderOffset ?? 0;
          span.forEach((entry) => {
            if (!entry) {
              return;
            }
            const fragment = state.stream.fragments.get(entry.id);
            const relativeIndex = (entry.canonicalIndex ?? 0) - (cluster.startIndex ?? 0);
            const renderIndex = relativeIndex - renderOffset;
            if (renderIndex < 0) {
              return;
            }
            const slotsLen = cluster.finalSlots?.length ?? 0;
            if (renderIndex >= slotsLen) {
              return;
            }
            const slot = cluster.finalSlots?.[renderIndex];
          if (!fragment) {
            if (slot) {
              occupiedSlots.add(slot);
            }
            return;
          }
            const slotX = fragment.isFading && fragment.fadeBaseX != null
              ? fragment.fadeBaseX
              : slot
              ? slot.x
              : (cluster.x ?? config.railPadding) + renderIndex * glyphWidth;
          const slotY = fragment.isFading && fragment.fadeBaseY != null
            ? fragment.fadeBaseY
            : slot
              ? slot.y
              : cluster.targetY ?? currentY;
          const drawX = slotX + (fragment.offsetX ?? 0);
          const drawY = currentY + (fragment.offsetY ?? 0);
          const rotation = fragment.rotation ?? 0;

          ctx.save();
          ctx.translate(drawX + glyphWidth / 2, drawY + config.fontSize / 2);
          ctx.rotate(rotation);
          ctx.translate(-glyphWidth / 2, -config.fontSize / 2);
          ctx.fillStyle = color;
          const alpha = fragment.opacity ?? 1;
          ctx.globalAlpha = clamp(alpha, 0, 1);
          ctx.fillText(fragment.ch, 0, 0);
          fragment.lastDrawX = drawX;
          fragment.lastDrawY = drawY;

          if (slot) {
            occupiedSlots.add(slot);
          }

          if (config.showFragmentBounds) {
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.65)';
            ctx.strokeRect(0, 0, glyphWidth, config.fontSize);
          }
          ctx.restore();

          if (config.showSlotVectors && slot) {
            ctx.save();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.35)';
            ctx.beginPath();
            ctx.moveTo(drawX + glyphWidth / 2, drawY + config.fontSize / 2);
            ctx.lineTo(slot.x + glyphWidth / 2, slot.y + config.fontSize / 2);
            ctx.stroke();
            ctx.restore();
          }

          if (config.showSlotBounds && slot) {
            ctx.save();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.35)';
            ctx.strokeRect(slot.x, slot.y, slot.width, slot.height);
            ctx.restore();
          }
        });

        if (config.showSlotBounds && Array.isArray(cluster.finalSlots)) {
          cluster.finalSlots.forEach((slot) => {
            if (!slot || occupiedSlots.has(slot)) {
              return;
            }
            ctx.save();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.35)';
            ctx.strokeRect(slot.x, slot.y, slot.width, slot.height);
            ctx.restore();
          });
        }

        ctx.globalAlpha = 1;
      };

      // ------------------------------------------------------------------
      // Layout helpers
      // ------------------------------------------------------------------

      /** Compute the fixed final slot positions for each character in a cluster. */
      const assignFinalSlots = (cluster) => {
        const glyphWidth = withGlyphWidth();
        const baseX = cluster.x ?? config.railPadding;
        const targetY = cluster.isFinal
          ? (typeof cluster.finalTargetY === 'number'
            ? cluster.finalTargetY
            : cluster.railY ?? state.metrics.railY)
          : (typeof state.pendingLineTargetY === 'number'
            ? state.pendingLineTargetY
            : typeof cluster.pendingTargetY === 'number'
              ? cluster.pendingTargetY
              : typeof cluster.finalTargetY === 'number'
                ? cluster.finalTargetY
                : cluster.railY ?? state.metrics.railY);
          const spanLength = Math.max(
            (cluster.endIndex ?? 0) - (cluster.startIndex ?? 0),
            0
          );
          const leadingInvisible = cluster.renderOffset ?? 0;
          const visibleLength = Math.max(spanLength - leadingInvisible, 0);
          const slots = [];

          for (let index = 0; index < visibleLength; index += 1) {
            slots.push({
              index,
            x: baseX + index * glyphWidth,
            y: targetY,
            width: glyphWidth,
            height: config.fontSize,
          });
        }

        cluster.finalSlots = slots;
      };

      // ------------------------------------------------------------------
      // Stream helpers
      // ------------------------------------------------------------------

      const ensureFragmentRandomization = (fragment) => {
        if (!config.fragmentRandomizationEnabled) {
          fragment.offsetX = 0;
          fragment.offsetY = 0;
          fragment.rotation = 0;
          fragment.speedMultiplier = 1;
          return;
        }
        fragment.offsetX = randomBetween(-config.fragmentMaxOffsetX, config.fragmentMaxOffsetX);
        fragment.offsetY = randomBetween(-config.fragmentMaxOffsetY, config.fragmentMaxOffsetY);
        fragment.rotation = randomBetween(-config.fragmentMaxRotation, config.fragmentMaxRotation);
        fragment.speedMultiplier = randomBetween(
          config.fragmentMoveSpeedMin,
          config.fragmentMoveSpeedMax
        );
      };

      const spawnFragmentForEntry = (entry) => {
        if (!isRenderableChar(entry.char)) {
          return null;
        }
        const fragment = {
          id: entry.id,
          ch: entry.char,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          speedMultiplier: 1,
          opacity: 1,
          isFading: false,
        };
        ensureFragmentRandomization(fragment);
        state.stream.fragments.set(entry.id, fragment);
        return fragment;
      };

      const scheduleFragmentFade = (entry) => {
        if (!entry) {
          return;
        }
        const fragment = state.stream.fragments.get(entry.id);
        if (!fragment) {
          return;
        }
        if (!fragment.isFading) {
          fragment.isFading = true;
          fragment.fadeBaseX = fragment.lastDrawX ?? fragment.fadeBaseX;
          fragment.fadeBaseY = fragment.lastDrawY ?? fragment.fadeBaseY;
        }
        state.stream.fading.add(fragment);
      };

      const buildSegmentsFromEvent = (event) => {
        const segments = [];
        for (let i = 0; i < event.results.length; i += 1) {
          const result = event.results[i];
          if (!result || !result[0]) {
            segments.push({
              index: i,
              rawTranscript: '',
              trimmedTranscript: '',
              normalized: '',
              leadingTrim: 0,
              isFinal: result ? result.isFinal === true : false,
            });
            continue;
          }
          const rawTranscript = result[0].transcript || '';
          const trimmedTranscript = rawTranscript.replace(/^\s+/, '');
          segments.push({
            index: i,
            rawTranscript,
            trimmedTranscript,
            normalized: trimmedTranscript.toLowerCase(),
            leadingTrim: Math.max(rawTranscript.length - trimmedTranscript.length, 0),
            isFinal: result.isFinal === true,
          });
        }
        return segments;
      };

      const buildStreamDescriptors = (segments) => {
        const chars = [];
        const ranges = [];
        let cursor = 0;
        segments.forEach((segment) => {
          const raw = segment.rawTranscript || '';
          const start = cursor;
          for (let i = 0; i < raw.length; i += 1) {
            chars.push({
              char: raw[i],
              isFinal: segment.isFinal,
              segmentIndex: segment.index,
            });
            cursor += 1;
          }
          ranges.push({
            index: segment.index,
            start,
            end: cursor,
            isFinal: segment.isFinal,
            trimmed: segment.trimmedTranscript || '',
            raw,
          });
        });
        return { chars, ranges };
      };

      const diffStreamEntries = (descriptors) => {
        const { chars } = descriptors;
        const oldEntries = state.stream.entries;
        const prevChars = oldEntries.map((entry) => entry.char);
        const nextChars = chars.map((item) => item.char);
        const lcsPairs = computeLCSPairs(prevChars, nextChars);

        const reusedOld = new Set();
        const reusedByNew = new Map();
        lcsPairs.forEach(([oldIdx, newIdx]) => {
          reusedOld.add(oldIdx);
          reusedByNew.set(newIdx, oldEntries[oldIdx]);
        });

        oldEntries.forEach((entry, idx) => {
          if (!reusedOld.has(idx)) {
            scheduleFragmentFade(entry);
          }
        });

        const newEntries = [];
        const createdIds = new Set();
        const reusedIds = new Set();
        chars.forEach((charInfo, newIdx) => {
          const existing = reusedByNew.get(newIdx);
          if (existing) {
            existing.canonicalIndex = newIdx;
            existing.segmentIndex = charInfo.segmentIndex;
            existing.char = charInfo.char;
            if (charInfo.isFinal) {
              existing.isFinal = true;
            }
            newEntries.push(existing);
            if (isRenderableChar(existing.char) && !state.stream.fragments.has(existing.id)) {
              spawnFragmentForEntry(existing);
            }
            reusedIds.add(existing.id);
          } else {
            const entry = {
              id: state.stream.nextId,
              char: charInfo.char,
              isFinal: !!charInfo.isFinal,
              segmentIndex: charInfo.segmentIndex,
              canonicalIndex: newIdx,
            };
            state.stream.nextId += 1;
            newEntries.push(entry);
            spawnFragmentForEntry(entry);
            if (isRenderableChar(entry.char)) {
              createdIds.add(entry.id);
            }
          }
        });

        state.stream.entries = newEntries;
        state.stream.lastDiff = {
          createdIds,
          reusedIds,
        };
      };

      /** Emit a console snapshot of current clusters and fragment positions. */
      const logRecognitionSnapshot = () => {
        const clusterSummaries = [];
        const fragmentSummaries = [];
        state.clusters.forEach((cluster, clusterIdx) => {
          const currentY =
            typeof cluster.y === 'number'
              ? cluster.y
              : typeof cluster.spawnY === 'number'
                ? cluster.spawnY
                : state.metrics.height - config.fontSize * 1.5;
          const stats = cluster.fragmentStats || { created: 0, reused: 0 };
          clusterSummaries.push({
            clusterId: cluster.id,
            order: clusterIdx,
            text: cluster.displayText || '',
            isFinal: cluster.isFinal,
            x: round2(cluster.x ?? config.railPadding),
            y: round2(currentY),
            fragmentsCreated: stats.created,
            fragmentsReused: stats.reused,
          });

          const span = state.stream.entries.slice(
            cluster.startIndex ?? 0,
            cluster.endIndex ?? 0
          );
          span.forEach((entry, relIdx) => {
            const fragment = state.stream.fragments.get(entry.id);
            if (!fragment) {
              return;
            }
            fragmentSummaries.push({
              clusterId: cluster.id,
              fragmentIndex: relIdx,
              char: entry.char,
              isFading: !!fragment.isFading,
              opacity: round2(fragment.opacity ?? 1),
              drawX: round2(fragment.lastDrawX ?? 0),
              drawY: round2(fragment.lastDrawY ?? 0),
            });
          });
        });

        try {
          console.table(clusterSummaries);
        } catch (err) {
          console.log('Cluster snapshot', clusterSummaries);
        }
        try {
          console.table(fragmentSummaries);
        } catch (err) {
          console.log('Fragment snapshot', fragmentSummaries);
        }
      };

      /**
       * Ensure the cluster has one fragment per rendered character, optionally applying
       * randomized offsets/rotation to create a scatter spawn effect.
       */
      /** Compute longest common subsequence index pairs between two strings. */
      const computeLCSPairs = (prev, next) => {
        const m = prev.length;
        const n = next.length;
        const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));

        for (let i = m - 1; i >= 0; i -= 1) {
          for (let j = n - 1; j >= 0; j -= 1) {
            if (prev[i] === next[j]) {
              dp[i][j] = dp[i + 1][j + 1] + 1;
            } else {
              dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
            }
          }
        }

        const pairs = [];
        let i = 0;
        let j = 0;
        while (i < m && j < n) {
          if (prev[i] === next[j]) {
            pairs.push([i, j]);
            i += 1;
            j += 1;
          } else if (dp[i + 1][j] >= dp[i][j + 1]) {
            i += 1;
          } else {
            j += 1;
          }
        }
        return pairs;
      };


      /** Main animation loop advancing clusters and issuing periodic debug logs. */
      const render = (now) => {
        const deltaSeconds = Math.min(
          Math.max((now - state.lastFrameTime) / 1000, 0),
          0.064
        );
        state.lastFrameTime = now;

        drawBackground();
        if (typeof state.pendingLineTargetY === 'number') {
          const firstPending = state.clusters.find((cluster) => !cluster.isFinal) || null;
          if (typeof state.pendingLineY !== 'number') {
            const spawnSource =
              (firstPending && typeof firstPending.spawnY === 'number'
                ? firstPending.spawnY
                : null) ??
              state.metrics.height - config.fontSize * 1.5;
            state.pendingLineY = spawnSource;
          }
          const dyGroup = state.pendingLineTargetY - state.pendingLineY;
          if (Math.abs(dyGroup) > 0.5) {
            const fallbackInitial = Math.abs(dyGroup) || 1;
            const pendingInitial =
              firstPending && typeof firstPending.pendingInitialDistance === 'number'
                ? firstPending.pendingInitialDistance
                : fallbackInitial;
            const initial = Math.max(pendingInitial, 1);
            const ratio = clamp(Math.abs(dyGroup) / initial, 0, 1);
            const speed =
              config.clusterRiseSpeedPending +
              (config.clusterRiseSpeedFinal - config.clusterRiseSpeedPending) * (1 - ratio);
            const groupStep = Math.sign(dyGroup) * speed * deltaSeconds;
            state.pendingLineY =
              Math.abs(groupStep) >= Math.abs(dyGroup)
                ? state.pendingLineTargetY
                : state.pendingLineY + groupStep;
          } else {
            state.pendingLineY = state.pendingLineTargetY;
          }
        }

        state.clusters.forEach((cluster) => {
          const targetY =
            typeof cluster.targetY === 'number' ? cluster.targetY : cluster.railY;
          if (typeof cluster.y !== 'number') {
            const spawnSource =
              typeof cluster.spawnY === 'number'
                ? cluster.spawnY
                : state.metrics.height - config.fontSize * 1.5;
            cluster.y = spawnSource;
          }
          if (typeof cluster.x !== 'number') {
            cluster.x = config.railPadding;
          }
          if (cluster.isFinal) {
            if (typeof targetY === 'number') {
              const dy = targetY - cluster.y;
              if (Math.abs(dy) > 0.5) {
                const initial = Math.max(
                  cluster.finalInitialDistance || Math.abs(dy),
                  1
                );
                const ratio = clamp(Math.abs(dy) / initial, 0, 1);
                const speed =
                  config.clusterRiseSpeedPending +
                  (config.clusterRiseSpeedFinal - config.clusterRiseSpeedPending) * (1 - ratio);
                const step = Math.sign(dy) * speed * deltaSeconds;
                cluster.y = Math.abs(step) >= Math.abs(dy) ? targetY : cluster.y + step;
              } else {
                cluster.y = targetY;
              }
            }
          } else if (typeof state.pendingLineY === 'number') {
            const dy = state.pendingLineY - (cluster.y ?? state.pendingLineY);
            if (Math.abs(dy) > 0.5) {
              const initial = Math.max(
                cluster.pendingInitialDistance || Math.abs(dy),
                1
              );
              const ratio = clamp(Math.abs(dy) / initial, 0, 1);
              const speed =
                config.clusterRiseSpeedPending +
                (config.clusterRiseSpeedFinal - config.clusterRiseSpeedPending) * (1 - ratio);
              const step = Math.sign(dy) * speed * deltaSeconds;
              cluster.y = Math.abs(step) >= Math.abs(dy) ? state.pendingLineY : (cluster.y ?? 0) + step;
            } else {
              cluster.y = state.pendingLineY;
            }
          }

          const spanEntries = state.stream.entries.slice(
            cluster.startIndex ?? 0,
            cluster.endIndex ?? 0
          );
          if (spanEntries.length) {
            const slotTargetY =
              typeof cluster.finalTargetY === 'number'
                ? cluster.finalTargetY
                : typeof cluster.targetY === 'number'
                  ? cluster.targetY
                  : cluster.railY;
            const initialDistance = Math.max(
              cluster.finalInitialDistance || 1,
              1
            );
            const distance = Math.abs((cluster.y ?? 0) - (slotTargetY ?? 0));
            const ratio = clamp(distance / initialDistance, 0, 1);
            const baseEase = Math.min(deltaSeconds * config.fragmentReturnSpeed, 1);
            const easing = config.fragmentRandomizationEnabled
              ? baseEase * (1 - ratio)
              : baseEase;

            spanEntries.forEach((entry, relIdx) => {
              const fragment = state.stream.fragments.get(entry.id);
              if (!fragment) {
                return;
              }
              const speedMul = fragment.speedMultiplier ?? 1;
              if (!config.fragmentRandomizationEnabled) {
                fragment.offsetX = 0;
                fragment.offsetY = 0;
                fragment.rotation = 0;
                fragment.speedMultiplier = 1;
              } else if (easing > 0) {
                fragment.offsetX -= fragment.offsetX * easing * speedMul;
                fragment.offsetY -= fragment.offsetY * easing * speedMul;
                fragment.rotation -= fragment.rotation * easing * speedMul;
              }

              if (fragment.isFading) {
                fragment.opacity =
                  fragment.opacity != null
                    ? fragment.opacity - Math.max(baseEase * 3, 0.5)
                    : 0;
              } else {
                fragment.opacity = Math.min(1, fragment.opacity ?? 1);
              }

              if (fragment.opacity <= 0) {
                state.stream.fragments.delete(entry.id);
                state.stream.fading.delete(fragment);
              }
            });
          }

          drawCluster(cluster);
        });

        if (state.stream.fading.size) {
          const removals = [];
          state.stream.fading.forEach((fragment) => {
            fragment.opacity =
              (fragment.opacity ?? 1) - deltaSeconds * config.fragmentReturnSpeed * 3;
            if (fragment.opacity <= 0) {
              removals.push(fragment);
            }
          });
          removals.forEach((fragment) => {
            state.stream.fading.delete(fragment);
            state.stream.fragments.delete(fragment.id);
          });
        }

        requestAnimationFrame(render);
      };

      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition;

      const resetScene = () => {
        state.clusters = [];
        state.clusterMap.clear();
        state.activeCluster = null;
        state.colorCursor = 0;
        state.pendingLineY = null;
        state.pendingLineTargetY = null;
        state.stream.entries = [];
        state.stream.fragments.clear();
        state.stream.fading.clear();
        state.stream.lastDiff = null;
        state.stream.nextId = 0;
        layoutClusters();
      };


      // ------------------------------------------------------------------
      // Speech recognition orchestration
      // ------------------------------------------------------------------

      /** Normalize a SpeechRecognition event payload back into stream + cluster state. */
      const handleResultEvent = (event) => {
        const segments = buildSegmentsFromEvent(event);
        if (!segments.length) {
          return;
        }

        const { chars, ranges } = buildStreamDescriptors(segments);
        diffStreamEntries({ chars, ranges });

        const clusters = [];
        const clusterMap = new Map();
        const diffMeta = state.stream.lastDiff || {
          createdIds: new Set(),
          reusedIds: new Set(),
        };
        segments.forEach((segment, idx) => {
          const range = ranges[idx];
          if (!range) {
            return;
          }
          if (range.start === range.end) {
            return;
          }
          const color =
            state.clusterMap.get(segment.index)?.color ?? nextClusterColor();
          const cluster = {
            id: segment.index,
            startIndex: range.start,
            endIndex: range.end,
            color,
            isFinal: segment.isFinal,
            displayText: segment.trimmedTranscript || segment.rawTranscript || '',
            finalTargetY: null,
            pendingTargetY: null,
            targetY: null,
            y: state.clusterMap.get(segment.index)?.y,
            railY: state.clusterMap.get(segment.index)?.railY ?? state.metrics.railY,
            spawnY: state.clusterMap.get(segment.index)?.spawnY ?? null,
            hasSpawned: state.clusterMap.get(segment.index)?.hasSpawned ?? false,
            pendingInitialDistance:
              state.clusterMap.get(segment.index)?.pendingInitialDistance ?? null,
            finalInitialDistance:
              state.clusterMap.get(segment.index)?.finalInitialDistance ?? null,
            renderOffset: 0,
          };
          const stats = { created: 0, reused: 0 };
          for (let pos = range.start; pos < range.end; pos += 1) {
            const entry = state.stream.entries[pos];
            if (!entry || !isRenderableChar(entry.char)) {
              continue;
            }
            if (diffMeta.createdIds?.has(entry.id)) {
              stats.created += 1;
            }
            if (diffMeta.reusedIds?.has(entry.id)) {
              stats.reused += 1;
            }
          }
          cluster.fragmentStats = stats;
          clusters.push(cluster);
          clusterMap.set(cluster.id, cluster);
        });

        state.clusters = clusters;
        state.clusterMap = clusterMap;
        layoutClusters();
        state.activeCluster = clusters.find((cluster) => !cluster.isFinal) || null;

        logRecognitionSnapshot();
      };

      /** Bootstrap the SpeechRecognition engine and wire event handlers. */
      const setupRecognition = () => {
        if (!SpeechRecognition) {
          warn('Web Speech API is not supported in this browser. Demo idle.');
          updateButtonUI({ label: 'Unsupported', disabled: true });
          return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onstart = () => {
          state.isListening = true;
          log('Speech recognition started.');
          resetScene();
          updateButtonUI({ disabled: false });
        };

        recognition.onresult = (event) => {
          try {
            handleResultEvent(event);
          } catch (err) {
            error('Failed to process recognition result:', err);
          }
        };

        recognition.onerror = (event) => {
          error('Speech recognition error:', event.error);
          if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
            state.keepListening = false;
            updateButtonUI({ disabled: false });
          }
          updateButtonUI();
        };

        recognition.onend = () => {
          state.isListening = false;
          log('Speech recognition stopped.');
          if (state.keepListening) {
            updateButtonUI({ disabled: true });
            try {
              recognition.start();
            } catch (err) {
              error('Unable to restart recognition:', err);
            }
          } else {
            updateButtonUI({ disabled: false });
          }
        };

        state.recognition = recognition;
        updateButtonUI({ disabled: false });
      };

      /** Begin audio capture if recognition is idle. */
      const startRecognition = () => {
        if (!state.recognition) {
          error('Speech recognition unavailable.');
          return;
        }
        if (state.isListening) {
          log('Recognition already running.');
          return;
        }
        state.keepListening = true;
        updateButtonUI({ disabled: true });
        try {
          state.recognition.start();
        } catch (err) {
          if (err && err.name === 'InvalidStateError') {
            log('Recognition already active.');
          } else {
            state.keepListening = false;
            error('Failed to start recognition:', err);
            updateButtonUI({ disabled: false });
          }
        }
      };

      /** Halt the active recognition session while respecting restart flags. */
      const stopRecognition = () => {
        if (!state.recognition) {
          error('Speech recognition unavailable.');
          return;
        }
        if (!state.isListening) {
          log('Recognition already stopped.');
          state.keepListening = false;
          updateButtonUI({ disabled: false });
          return;
        }
        state.keepListening = false;
        try {
          state.recognition.stop();
          updateButtonUI({ disabled: true });
        } catch (err) {
          error('Failed to stop recognition:', err);
          updateButtonUI({ disabled: false });
        }
      };

      setupRecognition();
      if (button) {
        button.addEventListener('click', () => {
          if (state.isListening) {
            stopRecognition();
          } else {
            startRecognition();
          }
        });

        if (randomToggle) {
          randomToggle.addEventListener('change', () => {
            config.fragmentRandomizationEnabled = randomToggle.checked;
            state.stream.fragments.forEach((fragment) => {
              if (config.fragmentRandomizationEnabled) {
                ensureFragmentRandomization(fragment);
              } else {
                fragment.offsetX = 0;
                fragment.offsetY = 0;
                fragment.rotation = 0;
                fragment.speedMultiplier = 1;
              }
            });
          });
        }

        if (fragmentBoundsToggle) {
          fragmentBoundsToggle.addEventListener('change', () => {
            config.showFragmentBounds = fragmentBoundsToggle.checked;
          });
        }

        if (slotBoundsToggle) {
          slotBoundsToggle.addEventListener('change', () => {
            config.showSlotBounds = slotBoundsToggle.checked;
          });
        }

        if (slotVectorToggle) {
          slotVectorToggle.addEventListener('change', () => {
            config.showSlotVectors = slotVectorToggle.checked;
          });
        }

        if (colorCodingToggle) {
          colorCodingToggle.addEventListener('change', () => {
            config.colorCodingEnabled = colorCodingToggle.checked;
          });
        }
      }

      state.lastFrameTime = performance.now();
      requestAnimationFrame(render);
    })();
  </script>
</body>

</html>
